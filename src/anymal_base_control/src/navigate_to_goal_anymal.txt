#include <anymal_base_control/navigate_to_goal_anymal.hpp>
#include <actionlib/client/simple_action_client.h>
#include <navigation_manager_msgs/NavigateToGoalAction.h>
#include <ros/ros.h>
#include <iostream>

using Client = actionlib::SimpleActionClient<navigation_manager_msgs::NavigateToGoalAction>;

class NavigateToGoalAnymal::Impl {
public:
  Impl() : client_("/path_planning_and_following/navigate_to_goal", true) {}

  void waitForServer() {
    client_.waitForServer();
  }

  void sendGoal(const geometry_msgs::Pose& pose, const std::string& frame_id) {
    navigation_manager_msgs::NavigateToGoalGoal goal;
    goal.goal.header.stamp = ros::Time::now();
    goal.goal.header.frame_id = frame_id;
    goal.goal.pose = pose;
    goal.goal.tolerance.translation = 0.01;
    goal.goal.tolerance.rotation = 0.05;
    goal.route_option.data = 0; // STRAIGHT_LINE

    std::cout << "Sending goal to: [" << pose.position.x << ", " << pose.position.y
              << ", " << pose.position.z << "]" << std::endl;
    client_.sendGoal(goal);
  }

  bool waitForResult(double timeout_seconds) {
    return client_.waitForResult(ros::Duration(timeout_seconds));
  }

  bool getResult() const {
    auto result = client_.getResult();
    return result && result->status == navigation_manager_msgs::NavigateToGoalResult::GOAL_REACHED;
  }

  void cancelGoal() {
    client_.cancelGoal();
  }

private:
  Client client_;
};

NavigateToGoalAnymal::NavigateToGoalAnymal() : impl_(new Impl) {}
void NavigateToGoalAnymal::waitForServer() { impl_->waitForServer(); }
void NavigateToGoalAnymal::sendGoal(const geometry_msgs::Pose& pose, const std::string& frame_id) { impl_->sendGoal(pose, frame_id); }
bool NavigateToGoalAnymal::waitForResult(double timeout_seconds) { return impl_->waitForResult(timeout_seconds); }
bool NavigateToGoalAnymal::getResult() const { return impl_->getResult(); }
void NavigateToGoalAnymal::cancelGoal() { impl_->cancelGoal(); }
